/* --------------------------------------------------------------------------------
 #
 #  4DPlugin-zint.cpp
 #	source generated by 4D Plugin Wizard
 #	Project : zint
 #	author : miyako
 #	2019/11/26
 #  
 # --------------------------------------------------------------------------------*/

#include "4DPlugin-zint.h"

#pragma mark -

void PluginMain(PA_long32 selector, PA_PluginParameters params) {
    
	try
	{
        switch(selector)
        {
			// --- zint
            
			case 1 :
				ZINT(params);
				break;

        }

	}
	catch(...)
	{

	}
}

#pragma mark -

void ZINT(PA_PluginParameters params) {

    PackagePtr pParams = (PackagePtr)params->fParameters;
    
    C_TEXT inData;
    inData.fromParamAtIndex(pParams, 1);
    
    PA_ObjectRef returnValue = PA_CreateObject();
    PA_ObjectRef options = PA_GetObjectParameter(params, 2);
        
    if(options) {

        zint_symbol *sym = ZBarcode_Create();
        
        if(sym) {
            int rotate_angle = 0;
            int dpi = 72;
            bool no_background = true;
            int format = (int)ob_get_n(options, L"format");
            sym->symbology = (int)ob_get_n(options, L"type");
            int height = (int)ob_get_n(options, L"height");
            if((height >= 1) && (height <= 1000))
            {
                sym->height = height;
            }
            int whitespace = (int)ob_get_n(options, L"white_space");
            if((whitespace >= 0) && (whitespace <= 1000))
            {
                sym->whitespace_width = whitespace;
            }
            int border = (int)ob_get_n(options, L"border");
            if((border >= 0) && (border <= 1000))
            {
                sym->border_width = border;
            }
            if(ob_get_b(options, L"box")) {
                sym->output_options += BARCODE_BOX;
            }
            if(ob_get_b(options, L"bind")) {
                sym->output_options += BARCODE_BIND;
            }
            if(ob_is_defined(options, L"no_background")) {
                no_background = ob_get_b(options, L"no_background");
            }
            if(ob_is_defined(options, L"GS1")) {
                if(ob_get_b(options, L"GS1")) {
                    sym->input_mode = GS1_MODE;
                }
            }
            if(ob_is_defined(options, L"no_text")) {
                if(ob_get_b(options, L"no_text")) {
                    sym->show_hrt = 0;
                }
            }
            if(ob_is_defined(options, L"square")) {
                if(ob_get_b(options, L"square")) {
                    sym->option_3 = DM_SQUARE;
                }
            }
            if(ob_is_defined(options, L"kanji")) {
                if(ob_get_b(options, L"kanji")) {
                    sym->input_mode = KANJI_MODE;//conversion is handled by zint
                }
            }
            if(ob_is_defined(options, L"SJIS")) {
                if(ob_get_b(options, L"SJIS")) {
                    sym->input_mode = SJIS_MODE;//conversion is handled by zint
                }
            }
            if(ob_is_defined(options, L"small_text")) {
                if(ob_get_b(options, L"small_text")) {
                    sym->output_options += SMALL_TEXT;
                }
            }
            int _dpi = (int)ob_get_n(options, L"dpi");
            if (_dpi > 72)
            {
                dpi = _dpi;
            }
            float scale = (float)ob_get_n(options, L"scale");
            if(scale >= 0.01)
            {
                sym->scale = scale;
            }
            int rotate = (int)ob_get_n(options, L"rotate");
            switch(rotate)
            {
                case 90: rotate_angle = 90; break;
                case 180: rotate_angle = 180; break;
                case 270: rotate_angle = 270; break;
                default: rotate_angle = 0; break;
            }
            int columns = (int)ob_get_n(options, L"columns");
            if((columns >= 1) && (columns <= 30))
            {
                sym->option_2 = columns;
            }
            int version = (int)ob_get_n(options, L"version");
            if((version >= 1) && (version <= 40))
            {
                sym->option_2 = version;
            }
            int secure = (int)ob_get_n(options, L"secure");
            if((secure >= 1) && (secure <= 8))
            {
                sym->option_1 = secure;
            }
            CUTF8String primary;
            if(ob_get_s(options, L"primary", &primary)) {
                if(primary.length() <= 90)
                {
                    strcpy(sym->primary, (const char *)primary.c_str());
                }
            }
            int mode = (int)ob_get_n(options, L"mode");
            if((mode >= 0) && (mode <= 6))
            {
                sym->option_1 = mode;
            }
            
            uint32_t dataSize = (inData.getUTF16Length() * sizeof(PA_Unichar) * 2)+ sizeof(uint8_t);
            std::vector<char> buf(dataSize);
            
			int n = 0;

			if (sym->input_mode == SJIS_MODE) {

				n = PA_ConvertCharsetToCharset((char *)inData.getUTF16StringPtr(),
					inData.getUTF16Length() * sizeof(PA_Unichar),
					eVTC_UTF_16,
					(char *)&buf[0],
					dataSize,
					eVTC_SHIFT_JIS);

			}
			else {

				n = PA_ConvertCharsetToCharset((char *)inData.getUTF16StringPtr(),
					inData.getUTF16Length() * sizeof(PA_Unichar),
					eVTC_UTF_16,
					(char *)&buf[0],
					dataSize,
					eVTC_UTF_8);
			}    
            
            switch (sym->symbology) {
                case BARCODE_MICROQR:
                    switch (sym->option_2) {
                        case 1:
                            sym->option_2 = 0;
                            break;
                        case 2:
                            sym->option_2 = 1;
                            break;
                        case 3:
                            sym->option_2 = 2;
                            break;
                        case 4:
                            sym->option_2 = 3;
                        default:
                            break;
                    }
                    break;
                    
                default:
                    break;
            }
            
            unsigned char *s = (unsigned char *)&buf[0];
            
            if(!ZBarcode_Encode(sym, s, n))
            {
                switch(format)
                {
                    case ZINT_OUTPUT_PNG:
                        toPNG(sym, dpi, rotate_angle, no_background, returnValue);
                        break;
                        
                    case ZINT_Format_SVG_12:
                        toSVG(sym, dpi, rotate_angle, no_background, returnValue, true);
                        break;
                        
                    case ZINT_OUTPUT_SVG:
                    default:
                        toSVG(sym, dpi, rotate_angle, no_background, returnValue);
                        break;
                }

            }
            ZBarcode_Delete(sym);
        }
  
    }
 
    PA_ReturnObject(params, returnValue);
}

#pragma mark -

namespace zint {
    int module_is_set(struct zint_symbol *symbol, int y_coord, int x_coord)
    {
        return (symbol->encoded_data[y_coord][x_coord / 7] >> (x_coord % 7)) & 1;
#if 0
        switch(x_sub) {
            case 0: if((symbol->encoded_data[y_coord][x_char] & 0x01) != 0) { result = 1; } break;
            case 1: if((symbol->encoded_data[y_coord][x_char] & 0x02) != 0) { result = 1; } break;
            case 2: if((symbol->encoded_data[y_coord][x_char] & 0x04) != 0) { result = 1; } break;
            case 3: if((symbol->encoded_data[y_coord][x_char] & 0x08) != 0) { result = 1; } break;
            case 4: if((symbol->encoded_data[y_coord][x_char] & 0x10) != 0) { result = 1; } break;
            case 5: if((symbol->encoded_data[y_coord][x_char] & 0x20) != 0) { result = 1; } break;
            case 6: if((symbol->encoded_data[y_coord][x_char] & 0x40) != 0) { result = 1; } break;
        }
        
        return result;
#endif
    }
    int ustrlen(unsigned char data[]) {
        /* Local replacement for strlen() with unsigned char strings */
        int i;
        for (i=0;data[i];i++);
        
        return i;
    }
    int is_extendable(int symbology) {
        /* Indicates which symbols can have addon */
        if(symbology == BARCODE_EANX) { return 1; }
        if(symbology == BARCODE_UPCA) { return 1; }
        if(symbology == BARCODE_UPCE) { return 1; }
        if(symbology == BARCODE_ISBNX) { return 1; }
        if(symbology == BARCODE_UPCA_CC) { return 1; }
        if(symbology == BARCODE_UPCE_CC) { return 1; }
        if(symbology == BARCODE_EANX_CC) { return 1; }
        
        return 0;
    }
    int is_stackable(int symbology) {
        /* Indicates which symbologies can have row binding */
        if(symbology < BARCODE_PDF417) { return 1; }
        if(symbology == BARCODE_CODE128B) { return 1; }
        if(symbology == BARCODE_ISBNX) { return 1; }
        if(symbology == BARCODE_EAN14) { return 1; }
        if(symbology == BARCODE_NVE18) { return 1; }
        if(symbology == BARCODE_KOREAPOST) { return 1; }
        if(symbology == BARCODE_PLESSEY) { return 1; }
        if(symbology == BARCODE_TELEPEN_NUM) { return 1; }
        if(symbology == BARCODE_ITF14) { return 1; }
        if(symbology == BARCODE_CODE32) { return 1; }
        
        return 0;
    }
    int round_up(float input)
    {
        float remainder;
        int integer_part;
        
        integer_part = (int)input;
        remainder = input - integer_part;
        
        if(remainder > 0.1) {
            integer_part++;
        }
        
        return integer_part;
    }
    void to_latin1(unsigned char source[], unsigned char preprocessed[])
    {
        int j, i, input_length;
        
        input_length = ustrlen(source);
        
        j = 0;
        i = 0;
        do {
            if(source[i] < 128) {
                preprocessed[j] = source[i];
                j++;
                i++;
            } else {
                if(source[i] == 0xC2) {
                    preprocessed[j] = source[i + 1];
                    j++;
                    i += 2;
                }
                if(source[i] == 0xC3) {
                    preprocessed[j] = source[i + 1] + 64;
                    j++;
                    i += 2;
                }
            }
        } while (i < input_length);
        preprocessed[j] = '\0';
        
        return;
    }
    void draw_bar(char *pixelbuf, int xpos, int xlen, int ypos, int ylen, int image_width, int image_height)
    {
        /* Draw a rectangle */
        int i, j, png_ypos;
        
        png_ypos = image_height - ypos - ylen;
        /* This fudge is needed because EPS measures height from the bottom up but
         PNG measures y position from the top down */
        
        for(i = (xpos); i < (xpos + xlen); i++) {
            for( j = (png_ypos); j < (png_ypos + ylen); j++) {
                *(pixelbuf + (image_width * j) + i) = '1';
            }
        }
    }
    void draw_letter(char *pixelbuf, unsigned char letter, int xposn, int yposn, int smalltext, int image_width, int image_height)
    {
        /* Put a letter into a position */
        int skip, i, j, glyph_no, alphabet;
        
        skip = 0;
        alphabet = 0;
        
        if(letter < 33) { skip = 1; }
        if((letter > 127) && (letter < 161)) { skip = 1; }
        
        if(skip == 0) {
            if(letter > 128) {
                alphabet = 1;
                glyph_no = letter - 161;
            } else {
                glyph_no = letter - 33;
            }
            
            if(smalltext) {
                for(i = 0; i <= 8; i++) {
                    for(j = 0; j < 5; j++) {
                        if(alphabet == 0) {
                            if(small_font[(glyph_no * 5) + (i * 475) + j - 1] == 1) {
                                *(pixelbuf + (i * image_width) + (yposn * image_width) + xposn + j) = '1';
                            }
                        } else {
                            if(small_font_extended[(glyph_no * 5) + (i * 475) + j - 1] == 1) {
                                *(pixelbuf + (i * image_width) + (yposn * image_width) + xposn + j) = '1';
                            }
                        }
                    }
                }
            } else {
                for(i = 0; i <= 13; i++) {
                    for(j = 0; j < 7 ; j++) {
                        if(alphabet == 0) {
                            if(ascii_font[(glyph_no * 7) + (i * 665) + j - 1] == 1) {
                                *(pixelbuf + (i * image_width) + (yposn * image_width) + xposn + j) = '1';
                            }
                        } else {
                            if(ascii_ext_font[(glyph_no * 7) + (i * 665) + j - 1] == 1) {
                                *(pixelbuf + (i * image_width) + (yposn * image_width) + xposn + j) = '1';
                            }
                        }
                    }
                }
            }
        }
    }
    void draw_string(char *pixbuf, char input_string[], int xposn, int yposn, int smalltext, int image_width, int image_height)
    {
        /* Plot a string into the pixel buffer */
        int i, string_length, string_left_hand;
        
        string_length = (int)strlen(input_string);
        string_left_hand = xposn - ((7 * string_length) / 2);
        
        for(i = 0; i < string_length; i++) {
            draw_letter(pixbuf, input_string[i], string_left_hand + (i * 7), yposn, smalltext, image_width, image_height);
        }
        
    }
    int bullseye_pixel(int row, int col) {
        int block_val, block_pos, return_val;
        
        block_val = bullseye_compressed[(row * 12) + (col / 8)];
        return_val = 0;
        block_pos = col % 8;
        
        switch(block_pos) {
            case 0: if((block_val & 0x80) != 0) { return_val = 1; } break;
            case 1: if((block_val & 0x40) != 0) { return_val = 1; } break;
            case 2: if((block_val & 0x20) != 0) { return_val = 1; } break;
            case 3: if((block_val & 0x10) != 0) { return_val = 1; } break;
            case 4: if((block_val & 0x08) != 0) { return_val = 1; } break;
            case 5: if((block_val & 0x04) != 0) { return_val = 1; } break;
            case 6: if((block_val & 0x02) != 0) { return_val = 1; } break;
            case 7: if((block_val & 0x01) != 0) { return_val = 1; } break;
        }
        
        return return_val;
    }
    void draw_bullseye(char *pixelbuf, int image_width, int xoffset, int yoffset)
    {
        /* Central bullseye in Maxicode symbols */
        int i, j;
        
        for(j = 103; j < 196; j++) {
            for(i = 0; i < 93; i++) {
                if(bullseye_pixel(j - 103, i)) {
                    /* if(bullseye[(((j - 103) * 93) + i)] == 1) { */
                    *(pixelbuf + (image_width * j) + (image_width * yoffset) + i + 99 + xoffset) = '1';
                }
            }
        }
    }
    void draw_hexagon(char *pixelbuf, int image_width, int xposn, int yposn)
    {
        /* Put a hexagon into the pixel buffer */
        int i, j;
        
        for(i = 0; i < 12; i++) {
            for(j = 0; j < 10; j++) {
                if(hexagon[(i * 10) + j] == 1) {
                    *(pixelbuf + (image_width * i) + (image_width * yposn) + xposn + j) = '1';
                }
            }
        }
    }
}

#pragma mark -

void write_data_fn(png_structp png_ptr, png_bytep buf, png_size_t size) {
    C_BLOB *blob = (C_BLOB *)png_get_io_ptr(png_ptr);
    blob->addBytes((const uint8_t *)buf, (uint32_t)size);
}

void output_flush_fn(png_structp png_ptr)
{
    
}

void toSVG(zint_symbol *symbol, int dpi, int rotate_angle, bool no_background, PA_ObjectRef o, bool isCMYK) {
    
        int i, block_width, latch, r, this_row;
        float textpos, large_bar_height, preset_height, row_height, row_posn = 0.0;
        int textoffset, xoffset, yoffset, textdone, main_width;
        char textpart[10], addon[6];
        int large_bar_count, comp_offset;
        float addon_text_posn;
        float scaler = symbol->scale;
        float default_text_posn;
        int plot_text = 1;

        row_height=0;
        textdone = 0;
        main_width = symbol->width;
        strcpy(addon, "");
        comp_offset = 0;
        addon_text_posn = 0.0;
        
        if (symbol->height == 0)
        {
            symbol->height = 50;
        }
        
        large_bar_count = 0;
        preset_height = 0.0;
        for(i = 0; i < symbol->rows; i++) {
            preset_height += symbol->row_height[i];
            if(symbol->row_height[i] == 0) {
                large_bar_count++;
            }
        }
        large_bar_height = (symbol->height - preset_height) / large_bar_count;
        
        if (large_bar_count == 0) {
            symbol->height = preset_height;
        }
        
        while(!(zint::module_is_set(symbol, symbol->rows - 1, comp_offset))) {
            comp_offset++;
        }
        
        /* Certain symbols need whitespace otherwise characters get chopped off the sides */
        if ((((symbol->symbology == BARCODE_EANX) && (symbol->rows == 1)) || (symbol->symbology == BARCODE_EANX_CC))
                || (symbol->symbology == BARCODE_ISBNX)) {
            switch(zint::ustrlen(symbol->text)) {
                case 13: /* EAN 13 */
                case 16:
                case 19:
                    if(symbol->whitespace_width == 0) {
                        symbol->whitespace_width = 10;
                    }
                    main_width = 96 + comp_offset;
                    break;
                default:
                    main_width = 68 + comp_offset;
            }
        }
        
        if (((symbol->symbology == BARCODE_UPCA) && (symbol->rows == 1)) || (symbol->symbology == BARCODE_UPCA_CC)) {
            if(symbol->whitespace_width == 0) {
                symbol->whitespace_width = 10;
                main_width = 96 + comp_offset;
            }
        }
        
        if (((symbol->symbology == BARCODE_UPCE) && (symbol->rows == 1)) || (symbol->symbology == BARCODE_UPCE_CC)) {
            if(symbol->whitespace_width == 0) {
                symbol->whitespace_width = 10;
                main_width = 51 + comp_offset;
            }
        }
        
        latch = 0;
        r = 0;
        /* Isolate add-on text */
        if(zint::is_extendable(symbol->symbology)) {
            for(i = 0; i < zint::ustrlen(symbol->text); i++) {
                if (latch == 1) {
                    addon[r] = symbol->text[i];
                    r++;
                }
                if (symbol->text[i] == '+') {
                    latch = 1;
                }
            }
        }
        addon[r] = '\0';
        
        if((symbol->show_hrt == 0) || (zint::ustrlen(symbol->text) == 0)) {
            plot_text = 0;
        }
        if(plot_text) {
            textoffset = 9;
        } else {
            textoffset = 0;
        }
        xoffset = symbol->border_width + symbol->whitespace_width;
        yoffset = symbol->border_width;
        
        if(((symbol->output_options & BARCODE_BOX) != 0) || ((symbol->output_options & BARCODE_BIND) != 0)) {
            default_text_posn = (symbol->height + textoffset + symbol->border_width + symbol->border_width) * scaler;
        } else {
            default_text_posn = (symbol->height + textoffset + symbol->border_width) * scaler;
        }
        
        
        std::string svg;
        svg += "<?xml version=\"1.0\" encoding=\"utf-8\" standalone=\"no\"?>\n";
    
        if(isCMYK){
            //no official DTD for SVG 1.2
        }else{
            svg += "<!DOCTYPE svg PUBLIC \"-//W3C//DTD SVG 1.1//EN\" \"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\">\n";
        }

        char _width[33];
        char _height[33];
        
        if(symbol->symbology != BARCODE_MAXICODE)
        {
            sprintf(_width, "%d", zint::round_up((symbol->width + xoffset + xoffset) * scaler));
            sprintf(_height, "%d", zint::round_up((symbol->height + textoffset + yoffset + yoffset) * scaler));
        } else
        {
            sprintf(_width, "%d", zint::round_up((74.0 + xoffset + xoffset) * scaler));
            sprintf(_height, "%d", zint::round_up((72.0 + yoffset + yoffset) * scaler));
        }

        char _dpi[33];
        sprintf(_dpi, "%d", dpi);
        
        if(isCMYK){
            svg += "<svg version=\"1.2\" width=\"100%\" height=\"100%\" viewBox=\"0 0 ";
        }else{
            svg += "<svg version=\"1.1\" width=\"100%\" height=\"100%\" viewBox=\"0 0 ";
        }
    
        switch (rotate_angle)
        {
      case 90:
      case 270:
                svg += _height;
                svg += " ";
                svg += _width;
            break;
      default:
            svg += _width;
            svg += " ";
            svg += _height;
            break;
        }
        svg += "\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:ns4d=\"http://www.4d.com\" ns4d:DPI=\"";
        svg += _dpi;
        if(no_background)
        {
            svg += "\" viewport-fill=\"none\" viewport-fill-opacity=\"0\">\n";
        }else
        {
            svg += "\">\n";
        }

        svg += "<desc>";
        if(zint::ustrlen(symbol->text) != 0) {
            svg += (const char *)symbol->text;
        } else {
            svg += "Zint Generated Symbol";
        }
        svg += "</desc>\n";
        
        svg += "<g shape-rendering=\"";
    //    if(symbol->symbology != BARCODE_MAXICODE)
    //    {
    //        svg += "crispEdges";
    //    }else
    //    {
            svg += "auto";
    //    }
        svg += "\" transform=\"translate(";
        switch (rotate_angle)
        {
      case 90:
                svg += _height;
                break;
      case 180:
                svg += _width;
                break;
      case 270:
                svg += "0";
                break;
      default:
                svg += "0";
                break;
        }
        svg += ",";
        switch (rotate_angle)
        {
      case 90:
                svg += "0";
                break;
      case 180:
                svg += _height;
                break;
      case 270:
                svg += _width;
                break;
      default:
                svg += "0";
                break;
        }
        svg += ") rotate(";
        switch (rotate_angle)
        {
        case 90:
            svg += "90";
            break;
        case 180:
            svg += "180";
            break;
        case 270:
            svg += "270";
            break;
        default:
            svg += "0";
            break;
        }
        svg += ",0,0)\" ";
        
        if(symbol->symbology != BARCODE_MAXICODE)
        {
            svg += "stroke-width=\"0\" stroke=\"none\">\n";
        }else
        {
            svg += ">\n";
        }

        char _x[33];
        char _y[33];
        char _w[33];
        char _h[33];
        char _font_size[33];
        
        char _r[33];
        
        char _ax[33];
        char _ay[33];
        char _bx[33];
        char _by[33];
        char _cx[33];
        char _cy[33];
        char _dx[33];
        char _dy[33];
        char _ex[33];
        char _ey[33];
        char _fx[33];
        char _fy[33];
        
        if(symbol->symbology != BARCODE_MAXICODE) {
            sprintf(_w, "%d", zint::round_up((symbol->width + xoffset + xoffset) * scaler));
            sprintf(_h, "%d", zint::round_up((symbol->height + textoffset + yoffset + yoffset) * scaler));
            
        } else {
            sprintf(_w, "%d", zint::round_up((74.0 + xoffset + xoffset) * scaler));
            sprintf(_h, "%d", zint::round_up((72.0 + yoffset + yoffset) * scaler));
        }

        svg += "<rect x=\"0\" y=\"0\" width=\"";
        svg += _w;
        svg += "\" height=\"";
        svg += _h;
        if(no_background)
        {
            svg +="\" fill=\"none\" />\n";
        }else{
            if(isCMYK){
                svg +="\" fill=\"#FFFFFF device-cmyk(0, 0, 0, 0)\" />\n";
            }else{
                svg +="\" fill=\"#FFFFFF\" />\n";
            }
        }

        if(symbol->symbology == BARCODE_MAXICODE) {
            /* Maxicode uses hexagons */
            float ax, ay, bx, by, cx, cy, dx, dy, ex, ey, fx, fy, mx, my;
            
            
            textoffset = 0.0;
            if (((symbol->output_options & BARCODE_BOX) != 0) || ((symbol->output_options & BARCODE_BIND) != 0)) {
                sprintf(_x, "%.2f", 0.0);
                sprintf(_y, "%.2f", 0.0);
                sprintf(_w, "%.2f", (74.0 + xoffset + xoffset) * scaler);
                sprintf(_h, "%.2f", symbol->border_width * scaler);
                svg += "<rect x=\"";
                svg += _x;
                svg += "\" y=\"";
                svg += _y;
                svg += "\" width=\"";
                svg += _w;
                svg += "\" height=\"";
                svg += _h;
                svg += "\" />\n";
                sprintf(_y, "%.2f", (72.0 + symbol->border_width) * scaler);
                svg += "<rect x=\"";
                svg += _x;
                svg += "\" y=\"";
                svg += _y;
                svg += "\" width=\"";
                svg += _w;
                svg += "\" height=\"";
                svg += _h;
                svg += "\" />\n";
            }
            if((symbol->output_options & BARCODE_BOX) != 0) {
                /* side bars */
                sprintf(_x, "%.2f", 0.0);
                sprintf(_y, "%.2f", 0.0);
                sprintf(_w, "%.2f", symbol->border_width * scaler);
                sprintf(_h, "%.2f", (72.0 + (2 * symbol->border_width)) * scaler);
                svg += "<rect x=\"";
                svg += _x;
                svg += "\" y=\"";
                svg += _y;
                svg += "\" width=\"";
                svg += _w;
                svg += "\" height=\"";
                svg += _h;
                svg += "\" />\n";
                sprintf(_x, "%.2f", (74.0 + xoffset + xoffset - symbol->border_width) * scaler);
                svg += "<rect x=\"";
                svg += _x;
                svg += "\" y=\"";
                svg += _y;
                svg += "\" width=\"";
                svg += _w;
                svg += "\" height=\"";
                svg += _h;
                svg += "\" />\n";
            }
            sprintf(_cx, "%.2f", (35.76 + xoffset) * scaler);
            sprintf(_cy, "%.2f", (35.60 + yoffset) * scaler);
    //        sprintf(_r, "%.2f", 10.85 * scaler);
            sprintf(_r, "%.2f", 9.91 * scaler);
            if(!no_background){
                //bg
                svg += "<circle cx=\"";
                svg += _cx;
                svg += "\" cy=\"";
                svg += _cy;
                svg += "\" r=\"";
                svg += _r;
                if(isCMYK){
                    svg += "\" stroke-width=\"0\" stroke=\"none\" fill=\"#FFFFFF device-cmyk(0, 0, 0, 0)\" />\n";
                }else{
                    svg += "\" stroke-width=\"0\" stroke=\"none\" fill=\"#FFFFFF\" />\n";
                }
            }
            
            svg += "<circle cx=\"";
            svg += _cx;
            svg += "\" cy=\"";
            svg += _cy;
            svg += "\" r=\"";
            svg += _r;
            if(isCMYK){
                svg += "\" stroke-width=\"1.88\" stroke=\"#000000 device-cmyk(0, 0, 0, 1)\" fill=\"none\" />\n";
            }else{
                svg += "\" stroke-width=\"1.88\" stroke=\"#000000\" fill=\"none\" />\n";
            }
            
            sprintf(_r, "%.2f", 6.15 * scaler);
            
            svg += "<circle cx=\"";
            svg += _cx;
            svg += "\" cy=\"";
            svg += _cy;
            svg += "\" r=\"";
            svg += _r;
            if(isCMYK){
                svg += "\" stroke-width=\"1.88\" stroke=\"#000000 device-cmyk(0, 0, 0, 1)\" fill=\"none\" />\n";
            }else{
                svg += "\" stroke-width=\"1.88\" stroke=\"#000000\" fill=\"none\" />\n";
            }
            
            sprintf(_r, "%.2f", 2.39 * scaler);
            
            svg += "<circle cx=\"";
            svg += _cx;
            svg += "\" cy=\"";
            svg += _cy;
            svg += "\" r=\"";
            svg += _r;
            if(isCMYK){
                svg += "\" stroke-width=\"1.88\" stroke=\"#000000 device-cmyk(0, 0, 0, 1)\" fill=\"none\" />\n";
                svg += "<g stroke-width=\"0.18\" stroke=\"#000000 device-cmyk(0, 0, 0, 1)\">\n";
            }else{
                svg += "\" stroke-width=\"1.88\" stroke=\"#000000\" fill=\"none\" />\n";
                svg += "<g stroke-width=\"0.18\" stroke=\"#000000\">\n";
            }
            
            for(r = 0; r < symbol->rows; r++) {
                for(i = 0; i < symbol->width; i++) {
                    if(zint::module_is_set(symbol, r, i)) {
                        /* Dump a hexagon */
                        my = r * 2.135 + 1.43;
                        ay = my + 1.0 + yoffset;
                        by = my + 0.5 + yoffset;
                        cy = my - 0.5 + yoffset;
                        dy = my - 1.0 + yoffset;
                        ey = my - 0.5 + yoffset;
                        fy = my + 0.5 + yoffset;
                        if(r & 1) {
                            mx = (2.46 * i) + 1.23 + 1.23;
                        } else {
                            mx = (2.46 * i) + 1.23;
                        }
                        ax = mx + xoffset;
                        bx = mx + 0.86 + xoffset;
                        cx = mx + 0.86 + xoffset;
                        dx = mx + xoffset;
                        ex = mx - 0.86 + xoffset;
                        fx = mx - 0.86 + xoffset;
                        sprintf(_ax, "%.2f", ax * scaler);
                        sprintf(_ay, "%.2f", ay * scaler);
                        sprintf(_bx, "%.2f", bx * scaler);
                        sprintf(_by, "%.2f", by * scaler);
                        sprintf(_cx, "%.2f", cx * scaler);
                        sprintf(_cy, "%.2f", cy * scaler);
                        sprintf(_dx, "%.2f", dx * scaler);
                        sprintf(_dy, "%.2f", dy * scaler);
                        sprintf(_ex, "%.2f", ex * scaler);
                        sprintf(_ey, "%.2f", ey * scaler);
                        sprintf(_fx, "%.2f", fx * scaler);
                        sprintf(_fy, "%.2f", fy * scaler);
                        svg += "<path d=\"M ";
                        svg += _ax;
                        svg += " ";
                        svg += _ay;
                        svg += " L ";
                        svg += _bx;
                        svg += " ";
                        svg += _by;
                        svg += " L ";
                        svg += _cx;
                        svg += " ";
                        svg += _cy;
                        svg += " L ";
                        svg += _dx;
                        svg += " ";
                        svg += _dy;
                        svg += " L ";
                        svg += _ex;
                        svg += " ";
                        svg += _ey;
                        svg += " L ";
                        svg += _fx;
                        svg += " ";
                        svg += _fy;
                        svg += " Z\" />\n";
                    }
                }
            }
            svg += "</g>\n";
        }
        
        if(symbol->symbology != BARCODE_MAXICODE) {
            /* everything else uses rectangles (or squares) */
            /* Works from the bottom of the symbol up */
            int addon_latch = 0;
            
            for(r = 0; r < symbol->rows; r++) {
                this_row = r;
                if(symbol->row_height[this_row] == 0) {
                    row_height = large_bar_height;
                } else {
                    row_height = symbol->row_height[this_row];
                }
                row_posn = 0;
                for(i = 0; i < r; i++) {
                    if(symbol->row_height[i] == 0) {
                        row_posn += large_bar_height;
                    } else {
                        row_posn += symbol->row_height[i];
                    }
                }
                row_posn += yoffset;
                
                i = 0;
                if(zint::module_is_set(symbol, this_row, 0)) {
                    latch = 1;
                } else {
                    latch = 0;
                }
                ::std::size_t outpos = 0;
                do {
                    block_width = 0;
                    //breathe every 8KO
                    if((outpos % 0x2000)==0) {
                        PA_YieldAbsolute();
                    }
                    outpos++;
                    do {
                        block_width++;
                    } while (zint::module_is_set(symbol, this_row, i + block_width) == zint::module_is_set(symbol, this_row, i));
                    if((addon_latch == 0) && (r == (symbol->rows - 1)) && (i > main_width)) {
                        addon_text_posn = (row_posn + 8.0) * scaler;
                        addon_latch = 1;
                    }
                    if(latch == 1) {
                        /* a bar */
                        if(addon_latch == 0)
                        {
                            sprintf(_x, "%.2f", (i + xoffset) * scaler);
                            sprintf(_y, "%.2f", row_posn * scaler);
                            sprintf(_w, "%.2f", block_width * scaler);
                            sprintf(_h, "%.2f", row_height * scaler);
                        } else
                        {
                            sprintf(_x, "%.2f", (i + xoffset) * scaler);
                            sprintf(_y, "%.2f", (row_posn + 10.0) * scaler);
                            sprintf(_w, "%.2f", block_width * scaler);
                            sprintf(_h, "%.2f", (row_height - 5.0) * scaler);
                        }
                        svg += "<rect x=\"";
                        svg += _x;
                        svg += "\" y=\"";
                        svg += _y;
                        svg += "\" width=\"";
                        svg += _w;
                        svg += "\" height=\"";
                        svg += _h;
                        svg += "\" />\n";
                        latch = 0;
                    } else {
                        /* a space */
                        latch = 1;
                    }
                    i += block_width;
                    
                } while (i < symbol->width);
            }
        }
        /* That's done the actual data area, everything else is human-friendly */

        xoffset += comp_offset;
        row_posn = (row_posn + large_bar_height) * scaler;
        
        if(plot_text) {
            if ((((symbol->symbology == BARCODE_EANX) && (symbol->rows == 1)) || (symbol->symbology == BARCODE_EANX_CC)) ||
                    (symbol->symbology == BARCODE_ISBNX)) {
                /* guard bar extensions and text formatting for EAN8 and EAN13 */
                switch(zint::ustrlen(symbol->text)) {
                    case 8: /* EAN-8 */
                    case 11:
                    case 14:
                        sprintf(_x, "%.2f", (0 + xoffset) * scaler);
                        sprintf(_y, "%.2f", row_posn);
                        sprintf(_w, "%.2f", scaler);
                        sprintf(_h, "%.2f", 5.0 * scaler);
                        svg += "<rect x=\"";
                        svg += _x;
                        svg += "\" y=\"";
                        svg += _y;
                        svg += "\" width=\"";
                        svg += _w;
                        svg += "\" height=\"";
                        svg += _h;
                        svg += "\" />\n";
                        sprintf(_x, "%.2f", (2 + xoffset) * scaler);
                        svg += "<rect x=\"";
                        svg += _x;
                        svg += "\" y=\"";
                        svg += _y;
                        svg += "\" width=\"";
                        svg += _w;
                        svg += "\" height=\"";
                        svg += _h;
                        svg += "\" />\n";
                        sprintf(_x, "%.2f", (32 + xoffset) * scaler);
                        svg += "<rect x=\"";
                        svg += _x;
                        svg += "\" y=\"";
                        svg += _y;
                        svg += "\" width=\"";
                        svg += _w;
                        svg += "\" height=\"";
                        svg += _h;
                        svg += "\" />\n";
                        sprintf(_x, "%.2f", (34 + xoffset) * scaler);
                        svg += "<rect x=\"";
                        svg += _x;
                        svg += "\" y=\"";
                        svg += _y;
                        svg += "\" width=\"";
                        svg += _w;
                        svg += "\" height=\"";
                        svg += _h;
                        svg += "\" />\n";
                        sprintf(_x, "%.2f", (64 + xoffset) * scaler);
                        svg += "<rect x=\"";
                        svg += _x;
                        svg += "\" y=\"";
                        svg += _y;
                        svg += "\" width=\"";
                        svg += _w;
                        svg += "\" height=\"";
                        svg += _h;
                        svg += "\" />\n";
                        sprintf(_x, "%.2f", (66 + xoffset) * scaler);
                        svg += "<rect x=\"";
                        svg += _x;
                        svg += "\" y=\"";
                        svg += _y;
                        svg += "\" width=\"";
                        svg += _w;
                        svg += "\" height=\"";
                        svg += _h;
                        svg += "\" />\n";
                        for(i = 0; i < 4; i++) {
                            textpart[i] = symbol->text[i];
                        }
                        textpart[4] = '\0';
                        textpos = 17;
                        sprintf(_x, "%.2f", (textpos + xoffset) * scaler);
                        sprintf(_y, "%.2f", default_text_posn);
                        sprintf(_font_size, "%.1f", 11.0 * scaler);
                        svg += "<text x=\"";
                        svg += _x;
                        svg += "\" y=\"";
                        svg += _y;
                        svg +="\" text-anchor=\"middle\" font-family=\"sans-serif\" font-size=\"";
                        svg += _font_size;
                        svg += "\">";
                        svg += (const char *)textpart;
                        svg += "</text>\n";
                        for(i = 0; i < 4; i++) {
                            textpart[i] = symbol->text[i + 4];
                        }
                        textpart[4] = '\0';
                        textpos = 50;
                        sprintf(_x, "%.2f", (textpos + xoffset) * scaler);
                        sprintf(_y, "%.2f", default_text_posn);
                        svg += "<text x=\"";
                        svg += _x;
                        svg += "\" y=\"";
                        svg += _y;
                        svg +="\" text-anchor=\"middle\" font-family=\"sans-serif\" font-size=\"";
                        svg += _font_size;
                        svg += "\">";
                        svg += (const char *)textpart;
                        svg += "</text>\n";
                        textdone = 1;
                        switch(strlen(addon)) {
                            case 2:
                                textpos = xoffset + 86;
                                sprintf(_x, "%.2f", textpos * scaler);
                                sprintf(_y, "%.2f", addon_text_posn * scaler);
                                svg += "<text x=\"";
                                svg += _x;
                                svg += "\" y=\"";
                                svg += _y;
                                svg +="\" text-anchor=\"middle\" font-family=\"sans-serif\" font-size=\"";
                                svg += _font_size;
                                svg += "\">";
                                svg += (const char *)addon;
                                svg += "</text>\n";
                                break;
                            case 5:
                                textpos = xoffset + 100;
                                sprintf(_x, "%.2f", textpos * scaler);
                                sprintf(_y, "%.2f", addon_text_posn * scaler);
                                svg += "<text x=\"";
                                svg += _x;
                                svg += "\" y=\"";
                                svg += _y;
                                svg +="\" text-anchor=\"middle\" font-family=\"sans-serif\" font-size=\"";
                                svg += _font_size;
                                svg += "\">";
                                svg += (const char *)addon;
                                svg += "</text>\n";
                                break;
                        }
                        
                        break;
                    case 13: /* EAN 13 */
                    case 16:
                    case 19:
                        sprintf(_x, "%.2f", (0 + xoffset) * scaler);
                        sprintf(_y, "%.2f", row_posn);
                        sprintf(_w, "%.2f", scaler);
                        sprintf(_h, "%.2f", 5.0 * scaler);
                        svg += "<rect x=\"";
                        svg += _x;
                        svg += "\" y=\"";
                        svg += _y;
                        svg += "\" width=\"";
                        svg += _w;
                        svg += "\" height=\"";
                        svg += _h;
                        svg += "\" />\n";
                        sprintf(_x, "%.2f", (2 + xoffset) * scaler);
                        svg += "<rect x=\"";
                        svg += _x;
                        svg += "\" y=\"";
                        svg += _y;
                        svg += "\" width=\"";
                        svg += _w;
                        svg += "\" height=\"";
                        svg += _h;
                        svg += "\" />\n";
                        sprintf(_x, "%.2f", (46 + xoffset) * scaler);
                        svg += "<rect x=\"";
                        svg += _x;
                        svg += "\" y=\"";
                        svg += _y;
                        svg += "\" width=\"";
                        svg += _w;
                        svg += "\" height=\"";
                        svg += _h;
                        svg += "\" />\n";
                        sprintf(_x, "%.2f", (48 + xoffset) * scaler);
                        svg += "<rect x=\"";
                        svg += _x;
                        svg += "\" y=\"";
                        svg += _y;
                        svg += "\" width=\"";
                        svg += _w;
                        svg += "\" height=\"";
                        svg += _h;
                        svg += "\" />\n";
                        sprintf(_x, "%.2f", (92 + xoffset) * scaler);
                        svg += "<rect x=\"";
                        svg += _x;
                        svg += "\" y=\"";
                        svg += _y;
                        svg += "\" width=\"";
                        svg += _w;
                        svg += "\" height=\"";
                        svg += _h;
                        svg += "\" />\n";
                        sprintf(_x, "%.2f", (94 + xoffset) * scaler);
                        svg += "<rect x=\"";
                        svg += _x;
                        svg += "\" y=\"";
                        svg += _y;
                        svg += "\" width=\"";
                        svg += _w;
                        svg += "\" height=\"";
                        svg += _h;
                        svg += "\" />\n";
                        textpart[0] = symbol->text[0];
                        textpart[1] = '\0';
                        textpos = -7;
                        sprintf(_x, "%.2f", (textpos + xoffset) * scaler);
                        sprintf(_y, "%.2f", default_text_posn);
                        sprintf(_font_size, "%.1f", 11.0 * scaler);
                        svg += "<text x=\"";
                        svg += _x;
                        svg += "\" y=\"";
                        svg += _y;
                        svg +="\" text-anchor=\"middle\" font-family=\"sans-serif\" font-size=\"";
                        svg += _font_size;
                        svg += "\">";
                        svg += (const char *)textpart;
                        svg += "</text>\n";
                        for(i = 0; i < 6; i++) {
                            textpart[i] = symbol->text[i + 1];
                        }
                        textpart[6] = '\0';
                        textpos = 24;
                        sprintf(_x, "%.2f", (textpos + xoffset) * scaler);
                        sprintf(_y, "%.2f", default_text_posn);
                        svg += "<text x=\"";
                        svg += _x;
                        svg += "\" y=\"";
                        svg += _y;
                        svg +="\" text-anchor=\"middle\" font-family=\"sans-serif\" font-size=\"";
                        svg += _font_size;
                        svg += "\">";
                        svg += (const char *)textpart;
                        svg += "</text>\n";
                        for(i = 0; i < 6; i++) {
                            textpart[i] = symbol->text[i + 7];
                        }
                        textpart[6] = '\0';
                        textpos = 71;
                        sprintf(_x, "%.2f", (textpos + xoffset) * scaler);
                        sprintf(_y, "%.2f", default_text_posn);
                        svg += "<text x=\"";
                        svg += _x;
                        svg += "\" y=\"";
                        svg += _y;
                        svg +="\" text-anchor=\"middle\" font-family=\"sans-serif\" font-size=\"";
                        svg += _font_size;
                        svg += "\">";
                        svg += (const char *)textpart;
                        svg += "</text>\n";
                        textdone = 1;
                        switch(strlen(addon)) {
                            case 2:
                                textpos = xoffset + 114;
                                sprintf(_x, "%.2f", textpos * scaler);
                                sprintf(_y, "%.2f", addon_text_posn * scaler);
                                svg += "<text x=\"";
                                svg += _x;
                                svg += "\" y=\"";
                                svg += _y;
                                svg +="\" text-anchor=\"middle\" font-family=\"sans-serif\" font-size=\"";
                                svg += _font_size;
                                svg += "\">";
                                svg += (const char *)addon;
                                svg += "</text>\n";
                                break;
                            case 5:
                                textpos = xoffset + 128;
                                sprintf(_x, "%.2f", textpos * scaler);
                                sprintf(_y, "%.2f", addon_text_posn * scaler);
                                svg += "<text x=\"";
                                svg += _x;
                                svg += "\" y=\"";
                                svg += _y;
                                svg +="\" text-anchor=\"middle\" font-family=\"sans-serif\" font-size=\"";
                                svg += _font_size;
                                svg += "\">";
                                svg += (const char *)addon;
                                svg += "</text>\n";
                                break;
                        }
                        break;
                        
                }
            }
            
            if (((symbol->symbology == BARCODE_UPCA) && (symbol->rows == 1)) || (symbol->symbology == BARCODE_UPCA_CC)) {
                /* guard bar extensions and text formatting for UPCA */
                latch = 1;
                
                i = 0 + comp_offset;
                do {
                    block_width = 0;
                    do {
                        block_width++;
                    } while (zint::module_is_set(symbol, symbol->rows - 1, i + block_width) == zint::module_is_set(symbol, symbol->rows - 1, i));
                    if(latch == 1) {
                        /* a bar */
                        sprintf(_x, "%.2f", (i + xoffset - comp_offset) * scaler);
                        sprintf(_y, "%.2f", row_posn);
                        sprintf(_w, "%.2f", block_width * scaler);
                        sprintf(_h, "%.2f", 5.0 * scaler);
                        svg += "<rect x=\"";
                        svg += _x;
                        svg += "\" y=\"";
                        svg += _y;
                        svg += "\" width=\"";
                        svg += _w;
                        svg += "\" height=\"";
                        svg += _h;
                        svg += "\" />\n";
                        latch = 0;
                    } else {
                        /* a space */
                        latch = 1;
                    }
                    i += block_width;
                } while (i < 11 + comp_offset);
                sprintf(_x, "%.2f", (46 + xoffset) * scaler);
                sprintf(_y, "%.2f", row_posn);
                sprintf(_w, "%.2f", scaler);
                sprintf(_h, "%.2f", 5.0 * scaler);
                svg += "<rect x=\"";
                svg += _x;
                svg += "\" y=\"";
                svg += _y;
                svg += "\" width=\"";
                svg += _w;
                svg += "\" height=\"";
                svg += _h;
                svg += "\" />\n";
                sprintf(_x, "%.2f", (48 + xoffset) * scaler);
                svg += "<rect x=\"";
                svg += _x;
                svg += "\" y=\"";
                svg += _y;
                svg += "\" width=\"";
                svg += _w;
                svg += "\" height=\"";
                svg += _h;
                svg += "\" />\n";
                latch = 1;
                i = 85 + comp_offset;
                do {
                    block_width = 0;
                    do {
                        block_width++;
                    } while (zint::module_is_set(symbol, symbol->rows - 1, i + block_width) == zint::module_is_set(symbol, symbol->rows - 1, i));
                    if(latch == 1) {
                        /* a bar */
                        sprintf(_x, "%.2f", (i + xoffset - comp_offset) * scaler);
                        sprintf(_y, "%.2f", row_posn);
                        sprintf(_w, "%.2f", block_width * scaler);
                        sprintf(_h, "%.2f", 5.0 * scaler);
                        svg += "<rect x=\"";
                        svg += _x;
                        svg += "\" y=\"";
                        svg += _y;
                        svg += "\" width=\"";
                        svg += _w;
                        svg += "\" height=\"";
                        svg += _h;
                        svg += "\" />\n";
                        latch = 0;
                    } else {
                        /* a space */
                        latch = 1;
                    }
                    i += block_width;
                } while (i < 96 + comp_offset);
                textpart[0] = symbol->text[0];
                textpart[1] = '\0';
                textpos = -5;
                sprintf(_x, "%.2f", (textpos + xoffset) * scaler);
                sprintf(_y, "%.2f", default_text_posn);
                sprintf(_font_size, "%.2f", 8.0 * scaler);
                svg += "<text x=\"";
                svg += _x;
                svg += "\" y=\"";
                svg += _y;
                svg +="\" text-anchor=\"middle\" font-family=\"sans-serif\" font-size=\"";
                svg += _font_size;
                svg += "\">";
                svg += (const char *)textpart;
                svg += "</text>\n";
                for(i = 0; i < 5; i++) {
                    textpart[i] = symbol->text[i + 1];
                }
                textpart[5] = '\0';
                textpos = 27;
                sprintf(_x, "%.2f", (textpos + xoffset) * scaler);
                sprintf(_font_size, "%.2f", 11.0 * scaler);
                svg += "<text x=\"";
                svg += _x;
                svg += "\" y=\"";
                svg += _y;
                svg +="\" text-anchor=\"middle\" font-family=\"sans-serif\" font-size=\"";
                svg += _font_size;
                svg += "\">";
                svg += (const char *)textpart;
                svg += "</text>\n";
                for(i = 0; i < 5; i++) {
                    textpart[i] = symbol->text[i + 6];
                }
                textpart[6] = '\0';
                textpos = 68;
                sprintf(_x, "%.2f", (textpos + xoffset) * scaler);
                svg += "<text x=\"";
                svg += _x;
                svg += "\" y=\"";
                svg += _y;
                svg +="\" text-anchor=\"middle\" font-family=\"sans-serif\" font-size=\"";
                svg += _font_size;
                svg += "\">";
                svg += (const char *)textpart;
                svg += "</text>\n";
                textpart[0] = symbol->text[11];
                textpart[1] = '\0';
                textpos = 100;
                sprintf(_x, "%.2f", (textpos + xoffset) * scaler);
                sprintf(_font_size, "%.2f", 8.0 * scaler);
                svg += "<text x=\"";
                svg += _x;
                svg += "\" y=\"";
                svg += _y;
                svg +="\" text-anchor=\"middle\" font-family=\"sans-serif\" font-size=\"";
                svg += _font_size;
                svg += "\">";
                svg += (const char *)textpart;
                svg += "</text>\n";
                textdone = 1;
                switch(strlen(addon)) {
                    case 2:
                        textpos = xoffset + 116;
                        sprintf(_x, "%.2f", textpos * scaler);
                        sprintf(_y, "%.2f", addon_text_posn * scaler);
                        sprintf(_font_size, "%.2f", 11.0 * scaler);
                        svg += "<text x=\"";
                        svg += _x;
                        svg += "\" y=\"";
                        svg += _y;
                        svg +="\" text-anchor=\"middle\" font-family=\"sans-serif\" font-size=\"";
                        svg += _font_size;
                        svg += "\">";
                        svg += (const char *)addon;
                        svg += "</text>\n";
                        break;
                    case 5:
                        textpos = xoffset + 130;
                        sprintf(_x, "%.2f", textpos * scaler);
                        sprintf(_y, "%.2f", addon_text_posn * scaler);
                        sprintf(_font_size, "%.2f", 11.0 * scaler);
                        svg += "<text x=\"";
                        svg += _x;
                        svg += "\" y=\"";
                        svg += _y;
                        svg +="\" text-anchor=\"middle\" font-family=\"sans-serif\" font-size=\"";
                        svg += _font_size;
                        svg += "\">";
                        svg += (const char *)addon;
                        svg += "</text>\n";
                        break;
                }
                
            }
            
            if (((symbol->symbology == BARCODE_UPCE) && (symbol->rows == 1)) || (symbol->symbology == BARCODE_UPCE_CC)) {
                /* guard bar extensions and text formatting for UPCE */
                sprintf(_x, "%.2f", (0 + xoffset) * scaler);
                sprintf(_y, "%.2f", row_posn);
                sprintf(_w, "%.2f", scaler);
                sprintf(_h, "%.2f", 5.0 * scaler);
                svg += "<rect x=\"";
                svg += _x;
                svg += "\" y=\"";
                svg += _y;
                svg += "\" width=\"";
                svg += _w;
                svg += "\" height=\"";
                svg += _h;
                svg += "\" />\n";
                sprintf(_x, "%.2f", (2 + xoffset) * scaler);
                svg += "<rect x=\"";
                svg += _x;
                svg += "\" y=\"";
                svg += _y;
                svg += "\" width=\"";
                svg += _w;
                svg += "\" height=\"";
                svg += _h;
                svg += "\" />\n";
                sprintf(_x, "%.2f", (46 + xoffset) * scaler);
                svg += "<rect x=\"";
                svg += _x;
                svg += "\" y=\"";
                svg += _y;
                svg += "\" width=\"";
                svg += _w;
                svg += "\" height=\"";
                svg += _h;
                svg += "\" />\n";
                sprintf(_x, "%.2f", (48 + xoffset) * scaler);
                svg += "<rect x=\"";
                svg += _x;
                svg += "\" y=\"";
                svg += _y;
                svg += "\" width=\"";
                svg += _w;
                svg += "\" height=\"";
                svg += _h;
                svg += "\" />\n";
                sprintf(_x, "%.2f", (50 + xoffset) * scaler);
                svg += "<rect x=\"";
                svg += _x;
                svg += "\" y=\"";
                svg += _y;
                svg += "\" width=\"";
                svg += _w;
                svg += "\" height=\"";
                svg += _h;
                svg += "\" />\n";
                textpart[0] = symbol->text[0];
                textpart[1] = '\0';
                textpos = -5;
                sprintf(_x, "%.2f", (textpos + xoffset) * scaler);
                sprintf(_y, "%.2f", default_text_posn);
                sprintf(_font_size, "%.2f", 8.0 * scaler);
                svg += "<text x=\"";
                svg += _x;
                svg += "\" y=\"";
                svg += _y;
                svg +="\" text-anchor=\"middle\" font-family=\"sans-serif\" font-size=\"";
                svg += _font_size;
                svg += "\">";
                svg += (const char *)textpart;
                svg += "</text>\n";
                for(i = 0; i < 6; i++) {
                    textpart[i] = symbol->text[i + 1];
                }
                textpart[6] = '\0';
                textpos = 24;
                sprintf(_x, "%.2f", (textpos + xoffset) * scaler);
                sprintf(_y, "%.2f", default_text_posn);
                sprintf(_font_size, "%.2f", 11.0 * scaler);
                svg += "<text x=\"";
                svg += _x;
                svg += "\" y=\"";
                svg += _y;
                svg +="\" text-anchor=\"middle\" font-family=\"sans-serif\" font-size=\"";
                svg += _font_size;
                svg += "\">";
                svg += (const char *)textpart;
                svg += "</text>\n";
                textpart[0] = symbol->text[7];
                textpart[1] = '\0';
                textpos = 55;
                sprintf(_x, "%.2f", (textpos + xoffset) * scaler);
                sprintf(_y, "%.2f", default_text_posn);
                sprintf(_font_size, "%.2f", 8.0 * scaler);
                svg += "<text x=\"";
                svg += _x;
                svg += "\" y=\"";
                svg += _y;
                svg +="\" text-anchor=\"middle\" font-family=\"sans-serif\" font-size=\"";
                svg += _font_size;
                svg += "\">";
                svg += (const char *)textpart;
                svg += "</text>\n";
                textdone = 1;
                switch(strlen(addon)) {
                    case 2:
                        textpos = xoffset + 70;
                        sprintf(_x, "%.2f", textpos * scaler);
                        sprintf(_y, "%.2f", addon_text_posn * scaler);
                        sprintf(_font_size, "%.2f", 11.0 * scaler);
                        svg += "<text x=\"";
                        svg += _x;
                        svg += "\" y=\"";
                        svg += _y;
                        svg +="\" text-anchor=\"middle\" font-family=\"sans-serif\" font-size=\"";
                        svg += _font_size;
                        svg += "\">";
                        svg += (const char *)addon;
                        svg += "</text>\n";
                        break;
                    case 5:
                        textpos = xoffset + 84;
                        sprintf(_x, "%.2f", textpos * scaler);
                        sprintf(_y, "%.2f", addon_text_posn * scaler);
                        sprintf(_font_size, "%.2f", 11.0 * scaler);
                        svg += "<text x=\"";
                        svg += _x;
                        svg += "\" y=\"";
                        svg += _y;
                        svg +="\" text-anchor=\"middle\" font-family=\"sans-serif\" font-size=\"";
                        svg += _font_size;
                        svg += "\">";
                        svg += (const char *)addon;
                        svg += "</text>\n";
                        break;
                }
                
            }
            
        }
        
        xoffset -= comp_offset;
        
        switch(symbol->symbology) {
            case BARCODE_MAXICODE:
                /* Do nothing! (It's already been done) */
                break;
            default:
                if((symbol->output_options & BARCODE_BIND) != 0) {
                    if((symbol->rows > 1) && (zint::is_stackable(symbol->symbology) == 1)) {
                        /* row binding */
                        for(r = 1; r < symbol->rows; r++) {
                            sprintf(_x, "%.2f", xoffset * scaler);
                            sprintf(_y, "%.2f", ((r * row_height) + yoffset - 1) * scaler);
                            sprintf(_w, "%.2f", symbol->width * scaler);
                            sprintf(_h, "%.2f", 2.0 * scaler);
                            svg += "<rect x=\"";
                            svg += _x;
                            svg += "\" y=\"";
                            svg += _y;
                            svg += "\" width=\"";
                            svg += _w;
                            svg += "\" height=\"";
                            svg += _h;
                            svg += "\" />\n";
                        }
                    }
                }
                if (((symbol->output_options & BARCODE_BOX) != 0) || ((symbol->output_options & BARCODE_BIND) != 0)) {
                    sprintf(_x, "%.2f", 0.0);
                    sprintf(_y, "%.2f", 0.0);
                    sprintf(_w, "%.2f", (symbol->width + xoffset + xoffset) * scaler);
                    sprintf(_h, "%.2f", symbol->border_width * scaler);
                    svg += "<rect x=\"";
                    svg += _x;
                    svg += "\" y=\"";
                    svg += _y;
                    svg += "\" width=\"";
                    svg += _w;
                    svg += "\" height=\"";
                    svg += _h;
                    svg += "\" />\n";
                    sprintf(_x, "%.2f", 0.0);
                    sprintf(_y, "%.2f", (symbol->height + symbol->border_width) * scaler);
                    sprintf(_w, "%.2f", (symbol->width + xoffset + xoffset) * scaler);
                    sprintf(_h, "%.2f", symbol->border_width * scaler);
                    svg += "<rect x=\"";
                    svg += _x;
                    svg += "\" y=\"";
                    svg += _y;
                    svg += "\" width=\"";
                    svg += _w;
                    svg += "\" height=\"";
                    svg += _h;
                    svg += "\" />\n";
                }
                if((symbol->output_options & BARCODE_BOX) != 0) {
                    /* side bars */
                    sprintf(_x, "%.2f", 0.0);
                    sprintf(_y, "%.2f", 0.0);
                    sprintf(_w, "%.2f", symbol->border_width * scaler);
                    sprintf(_h, "%.2f", (symbol->height + (2 * symbol->border_width)) * scaler);
                    svg += "<rect x=\"";
                    svg += _x;
                    svg += "\" y=\"";
                    svg += _y;
                    svg += "\" width=\"";
                    svg += _w;
                    svg += "\" height=\"";
                    svg += _h;
                    svg += "\" />\n";
                    sprintf(_x, "%.2f", (symbol->width + xoffset + xoffset - symbol->border_width) * scaler);
                    sprintf(_y, "%.2f", 0.0);
                    sprintf(_w, "%.2f", symbol->border_width * scaler);
                    sprintf(_h, "%.2f", (symbol->height + (2 * symbol->border_width)) * scaler);
                    svg += "<rect x=\"";
                    svg += _x;
                    svg += "\" y=\"";
                    svg += _y;
                    svg += "\" width=\"";
                    svg += _w;
                    svg += "\" height=\"";
                    svg += _h;
                    svg += "\" />\n";
                }
                break;
        }
        
        /* Put the human readable text at the bottom */
        if(plot_text && (textdone == 0)) {
            textpos = symbol->width / 2.0;
            sprintf(_font_size, "%.1f", 8.0 * scaler);
            sprintf(_x, "%.2f", (textpos + xoffset) * scaler);
            sprintf(_y, "%.2f", default_text_posn);
            svg += "<text x=\"";
            svg += _x;
            svg += "\" y=\"";
            svg += _y;
            svg +="\" text-anchor=\"middle\" font-family=\"sans-serif\" font-size=\"";
            svg += _font_size;
            svg += "\">";
            svg += (const char *)symbol->text;
            svg += "</text>\n";
        }
        
        svg += "</g>\n";
        svg += "</svg>\n";
        
    if(o) {
        
        CUTF8String _svg((const uint8_t *)svg.c_str());
        ob_set_s(o, L"data", (const char *)_svg.c_str());
        
        PA_Picture p = PA_CreatePicture((void *)svg.c_str(), (PA_long32)svg.size());
        PA_Variable v = PA_CreateVariable(eVK_Picture);
        PA_SetPictureVariable(&v, p);/* we let go, so don't dispose */
        
        CUTF16String ukey;
        json_wconv(L"image", &ukey);
        PA_Unistring key = PA_CreateUnistring((PA_Unichar *)ukey.c_str());
        
        PA_SetObjectProperty(o, &key, v);
        
        PA_DisposeUnistring(&key);/* we still own it, so dispose */
        PA_ClearVariable(&v);
    }
}

void toPNG(zint_symbol *symbol, int dpi, int rotate_angle, bool no_background, PA_ObjectRef o) {

        //parameters to png_pixel_plot
        int image_height = 0;
        int image_width = 0;
        char *pixelbuf = NULL;
        
        if(symbol->symbology == BARCODE_MAXICODE)
        {
            int i, row, column, xposn, yposn;
            int xoffset, yoffset;
            
            xoffset = symbol->border_width + symbol->whitespace_width;
            yoffset = symbol->border_width;
            image_width = 300 + (2 * xoffset * 2);
            image_height = 300 + (2 * yoffset * 2);
            
            pixelbuf = (char *)malloc(image_width * image_height);
            
            if(pixelbuf)
            {
                for(i = 0; i < (image_width * image_height); i++) {
                    *(pixelbuf + i) = '0';
                }
                
                zint::draw_bullseye(pixelbuf, image_width, (2 * xoffset), (2 * yoffset));
                
                for(row = 0; row < symbol->rows; row++) {
                    yposn = row * 9;
                    for(column = 0; column < symbol->width; column++) {
                        xposn = column * 10;
                        if(zint::module_is_set(symbol, row, column)) {
                            if(row & 1) {
                                /* Odd (reduced) row */
                                xposn += 5;
                                zint::draw_hexagon(pixelbuf, image_width, xposn + (2 * xoffset), yposn + (2 * yoffset));
                            } else {
                                /* Even (full) row */
                                zint::draw_hexagon(pixelbuf, image_width, xposn + (2 * xoffset), yposn + (2 * yoffset));
                            }
                        }
                    }
                }

                if(((symbol->output_options & BARCODE_BOX) != 0) || ((symbol->output_options & BARCODE_BIND) != 0)) {
                    /* boundary bars */
                    zint::draw_bar(pixelbuf, 0, image_width, 0, symbol->border_width * 2, image_width, image_height);
                    zint::draw_bar(pixelbuf, 0, image_width, 300 + (symbol->border_width * 2), symbol->border_width * 2, image_width, image_height);
                }
                
                if((symbol->output_options & BARCODE_BOX) != 0) {
                    /* side bars */
                    zint::draw_bar(pixelbuf, 0, symbol->border_width * 2, 0, image_height, image_width, image_height);
                    zint::draw_bar(pixelbuf, 300 + ((symbol->border_width + symbol->whitespace_width + symbol->whitespace_width) * 2), symbol->border_width * 2, 0, image_height, image_width, image_height);
                }
                
            }
            
        }else
        {
    #ifndef _MSC_VER
            unsigned char local_text[zint::ustrlen(symbol->text) + 1];
    #else
            unsigned char* local_text = (unsigned char*)_alloca(zint::ustrlen(symbol->text) + 1);
    #endif
            if(symbol->show_hrt != 0) {
                zint::to_latin1(symbol->text, local_text);
            } else {
                local_text[0] = '\0';
            }
            int textdone, main_width, comp_offset, large_bar_count;
            char textpart[10], addon[6];
            float addon_text_posn, preset_height, large_bar_height;
            int i, r, textoffset, yoffset, xoffset, latch;
            
            int addon_latch = 0, smalltext = 0;
            int this_row, block_width, plot_height, plot_yposn, textpos;
            float row_height, row_posn;
            int default_text_posn;
            int next_yposn;
            
            textdone = 0;
            main_width = symbol->width;
            strcpy(addon, "");
            comp_offset = 0;
            addon_text_posn = 0.0;
            row_height = 0;
            if(symbol->output_options & SMALL_TEXT) {
                smalltext = 1;
            }
            
            if (symbol->height == 0) {
                symbol->height = 50;
            }
            
            large_bar_count = 0;
            preset_height = 0.0;
            for(i = 0; i < symbol->rows; i++) {
                preset_height += symbol->row_height[i];
                if(symbol->row_height[i] == 0) {
                    large_bar_count++;
                }
            }
            
            if (large_bar_count == 0) {
                symbol->height = preset_height;
                large_bar_height = 10;
            } else {
                large_bar_height = (symbol->height - preset_height) / large_bar_count;
            }
            
            while(!(zint::module_is_set(symbol, symbol->rows - 1, comp_offset))) {
                comp_offset++;
            }
            
            /* Certain symbols need whitespace otherwise characters get chopped off the sides */
            if ((((symbol->symbology == BARCODE_EANX) && (symbol->rows == 1)) || (symbol->symbology == BARCODE_EANX_CC))
                    || (symbol->symbology == BARCODE_ISBNX)) {
                switch(zint::ustrlen(local_text)) {
                    case 13: /* EAN 13 */
                    case 16:
                    case 19:
                        if(symbol->whitespace_width == 0) {
                            symbol->whitespace_width = 10;
                        }
                        main_width = 96 + comp_offset;
                        break;
                    default:
                        main_width = 68 + comp_offset;
                }
            }
            
            if (((symbol->symbology == BARCODE_UPCA) && (symbol->rows == 1)) || (symbol->symbology == BARCODE_UPCA_CC)) {
                if(symbol->whitespace_width == 0) {
                    symbol->whitespace_width = 10;
                    main_width = 96 + comp_offset;
                }
            }
            
            if (((symbol->symbology == BARCODE_UPCE) && (symbol->rows == 1)) || (symbol->symbology == BARCODE_UPCE_CC)) {
                if(symbol->whitespace_width == 0) {
                    symbol->whitespace_width = 10;
                    main_width = 51 + comp_offset;
                }
            }
            
            latch = 0;
            r = 0;
            
            /* Isolate add-on text */
            if(zint::is_extendable(symbol->symbology)) {
                for(i = 0; i < zint::ustrlen(local_text); i++) {
                    if (latch == 1) {
                        addon[r] = local_text[i];
                        r++;
                    }
                    if (symbol->text[i] == '+') {
                        latch = 1;
                    }
                }
            }
            addon[r] = '\0';
            
            if(zint::ustrlen(local_text) != 0) {
                textoffset = 9;
            } else {
                textoffset = 0;
            }
            xoffset = symbol->border_width + symbol->whitespace_width;
            yoffset = symbol->border_width;
            image_width = 2 * (symbol->width + xoffset + xoffset);
            image_height = 2 * (symbol->height + textoffset + yoffset + yoffset);
            
            pixelbuf = (char *)malloc(image_width * image_height);
            
            if(pixelbuf)
            {
                for(i = 0; i < (image_width * image_height); i++)
                {
                    *(pixelbuf + i) = '0';
                }
                
                if(((symbol->output_options & BARCODE_BOX) != 0) || ((symbol->output_options & BARCODE_BIND) != 0)) {
                    default_text_posn = image_height - 17;
                } else {
                    default_text_posn = image_height - 17 - symbol->border_width - symbol->border_width;
                }
                
                row_posn = textoffset + yoffset;
                next_yposn = textoffset + yoffset;
                row_height = 0;
                
                /* Plot the body of the symbol to the pixel buffer */
                for(r = 0; r < symbol->rows; r++) {
                    this_row = symbol->rows - r - 1; /* invert r otherwise plots upside down */
                    row_posn += row_height;
                    plot_yposn = next_yposn;
                    if(symbol->row_height[this_row] == 0) {
                        row_height = large_bar_height;
                    } else {
                        row_height = symbol->row_height[this_row];
                    }
                    next_yposn = (int)(row_posn + row_height);
                    plot_height = next_yposn - plot_yposn;
                    
                    i = 0;
                    if(zint::module_is_set(symbol, this_row, 0)) {
                        latch = 1;
                    } else {
                        latch = 0;
                    }
                    ::std::size_t outpos = 0;
                    do {
                        block_width = 0;
                        //breathe every 8KO
                        if((outpos % 0x2000)==0) {
                            PA_YieldAbsolute();
                        }
                        outpos++;
                        do {
                            block_width++;
                        } while (zint::module_is_set(symbol, this_row, i + block_width) == zint::module_is_set(symbol, this_row, i));
                        if((addon_latch == 0) && (r == 0) && (i > main_width)) {
                            plot_height = (int)(row_height - 5.0);
                            plot_yposn = (int)(row_posn - 5.0);
                            addon_text_posn = row_posn + row_height - 8.0;
                            addon_latch = 1;
                        }
                        if(latch == 1) {
                            /* a bar */
                            zint::draw_bar(pixelbuf, (i + xoffset) * 2, block_width * 2, plot_yposn * 2, plot_height * 2, image_width, image_height);
                            latch = 0;
                        } else {
                            /* a space */
                            latch = 1;
                        }
                        i += block_width;
                        
                    } while (i < symbol->width);
                }
                
                xoffset += comp_offset;
                
                if ((((symbol->symbology == BARCODE_EANX) && (symbol->rows == 1)) || (symbol->symbology == BARCODE_EANX_CC)) || (symbol->symbology == BARCODE_ISBNX)) {
                    /* guard bar extensions and text formatting for EAN8 and EAN13 */
                    switch(zint::ustrlen(local_text)) {
                        case 8: /* EAN-8 */
                        case 11:
                        case 14:
                            zint::draw_bar(pixelbuf, (0 + xoffset) * 2, 1 * 2, (4 + (int)yoffset) * 2, 5 * 2, image_width, image_height);
                            zint::draw_bar(pixelbuf, (2 + xoffset) * 2, 1 * 2, (4 + (int)yoffset) * 2, 5 * 2, image_width, image_height);
                            zint::draw_bar(pixelbuf, (32 + xoffset) * 2, 1 * 2, (4 + (int)yoffset) * 2, 5 * 2, image_width, image_height);
                            zint::draw_bar(pixelbuf, (34 + xoffset) * 2, 1 * 2, (4 + (int)yoffset) * 2, 5 * 2, image_width, image_height);
                            zint::draw_bar(pixelbuf, (64 + xoffset) * 2, 1 * 2, (4 + (int)yoffset) * 2, 5 * 2, image_width, image_height);
                            zint::draw_bar(pixelbuf, (66 + xoffset) * 2, 1 * 2, (4 + (int)yoffset) * 2, 5 * 2, image_width, image_height);
                            for(i = 0; i < 4; i++) {
                                textpart[i] = symbol->text[i];
                            }
                            textpart[4] = '\0';
                            textpos = 2 * (17 + xoffset);
                            
                            zint::draw_string(pixelbuf, textpart, textpos, default_text_posn, smalltext, image_width, image_height);
                            for(i = 0; i < 4; i++) {
                                textpart[i] = symbol->text[i + 4];
                            }
                            textpart[4] = '\0';
                            textpos = 2 * (50 + xoffset);
                            zint::draw_string(pixelbuf, textpart, textpos, default_text_posn, smalltext, image_width, image_height);
                            textdone = 1;
                            switch(strlen(addon)) {
                                case 2:
                                    textpos = 2 * (xoffset + 86);
                                    zint::draw_string(pixelbuf, addon, textpos, image_height - (addon_text_posn * 2) - 13, smalltext, image_width, image_height);
                                    break;
                                case 5:
                                    textpos = 2 * (xoffset + 100);
                                    zint::draw_string(pixelbuf, addon, textpos, image_height - (addon_text_posn * 2) - 13, smalltext, image_width, image_height);
                                    break;
                            }
                            
                            break;
                        case 13: /* EAN 13 */
                        case 16:
                        case 19:
                            zint::draw_bar(pixelbuf, (0 + xoffset) * 2, 1 * 2, (4 + (int)yoffset) * 2, 5 * 2, image_width, image_height);
                            zint::draw_bar(pixelbuf, (2 + xoffset) * 2, 1 * 2, (4 + (int)yoffset) * 2, 5 * 2, image_width, image_height);
                            zint::draw_bar(pixelbuf, (46 + xoffset) * 2, 1 * 2, (4 + (int)yoffset) * 2, 5 * 2, image_width, image_height);
                            zint::draw_bar(pixelbuf, (48 + xoffset) * 2, 1 * 2, (4 + (int)yoffset) * 2, 5 * 2, image_width, image_height);
                            zint::draw_bar(pixelbuf, (92 + xoffset) * 2, 1 * 2, (4 + (int)yoffset) * 2, 5 * 2, image_width, image_height);
                            zint::draw_bar(pixelbuf, (94 + xoffset) * 2, 1 * 2, (4 + (int)yoffset) * 2, 5 * 2, image_width, image_height);
                            
                            textpart[0] = symbol->text[0];
                            textpart[1] = '\0';
                            textpos = 2 * (-7 + xoffset);
                            zint::draw_string(pixelbuf, textpart, textpos, default_text_posn, smalltext, image_width, image_height);
                            for(i = 0; i < 6; i++) {
                                textpart[i] = symbol->text[i + 1];
                            }
                            textpart[6] = '\0';
                            textpos = 2 * (24 + xoffset);
                            zint::draw_string(pixelbuf, textpart, textpos, default_text_posn, smalltext, image_width, image_height);
                            for(i = 0; i < 6; i++) {
                                textpart[i] = symbol->text[i + 7];
                            }
                            textpart[6] = '\0';
                            textpos = 2 * (71 + xoffset);
                            zint::draw_string(pixelbuf, textpart, textpos, default_text_posn, smalltext, image_width, image_height);
                            textdone = 1;
                            switch(strlen(addon)) {
                                case 2:
                                    textpos = 2 * (xoffset + 114);
                                    zint::draw_string(pixelbuf, addon, textpos, image_height - (addon_text_posn * 2) - 13, smalltext, image_width, image_height);
                                    break;
                                case 5:
                                    textpos = 2 * (xoffset + 128);
                                    zint::draw_string(pixelbuf, addon, textpos, image_height - (addon_text_posn * 2) - 13, smalltext, image_width, image_height);
                                    break;
                            }
                            break;
                            
                    }
                }
                
                if (((symbol->symbology == BARCODE_UPCA) && (symbol->rows == 1)) || (symbol->symbology == BARCODE_UPCA_CC)) {
                    /* guard bar extensions and text formatting for UPCA */
                    latch = 1;
                    
                    i = 0 + comp_offset;
                    do {
                        block_width = 0;
                        do {
                            block_width++;
                        } while (zint::module_is_set(symbol, symbol->rows - 1, i + block_width) == zint::module_is_set(symbol, symbol->rows - 1, i));
                        if(latch == 1) {
                            /* a bar */
                            zint::draw_bar(pixelbuf, (i + xoffset - comp_offset) * 2, block_width * 2, (4 + (int)yoffset) * 2, 5 * 2, image_width, image_height);
                            latch = 0;
                        } else {
                            /* a space */
                            latch = 1;
                        }
                        i += block_width;
                    } while (i < 11 + comp_offset);
                    zint::draw_bar(pixelbuf, (46 + xoffset) * 2, 1 * 2, (4 + (int)yoffset) * 2, 5 * 2, image_width, image_height);
                    zint::draw_bar(pixelbuf, (48 + xoffset) * 2, 1 * 2, (4 + (int)yoffset) * 2, 5 * 2, image_width, image_height);
                    latch = 1;
                    i = 85 + comp_offset;
                    do {
                        block_width = 0;
                        do {
                            block_width++;
                        } while (zint::module_is_set(symbol, symbol->rows - 1, i + block_width) == zint::module_is_set(symbol, symbol->rows - 1, i));
                        if(latch == 1) {
                            /* a bar */
                            zint::draw_bar(pixelbuf, (i + xoffset - comp_offset) * 2, block_width * 2, (4 + (int)yoffset) * 2, 5 * 2, image_width, image_height);
                            latch = 0;
                        } else {
                            /* a space */
                            latch = 1;
                        }
                        i += block_width;
                    } while (i < 96 + comp_offset);
                    textpart[0] = symbol->text[0];
                    textpart[1] = '\0';
                    textpos = 2 * (-5 + xoffset);
                    zint::draw_string(pixelbuf, textpart, textpos, default_text_posn, smalltext, image_width, image_height);
                    for(i = 0; i < 5; i++) {
                        textpart[i] = symbol->text[i + 1];
                    }
                    textpart[5] = '\0';
                    textpos = 2 * (27 + xoffset);
                    zint::draw_string(pixelbuf, textpart, textpos, default_text_posn, smalltext, image_width, image_height);
                    for(i = 0; i < 5; i++) {
                        textpart[i] = symbol->text[i + 6];
                    }
                    textpart[6] = '\0';
                    textpos = 2 * (68 + xoffset);
                    zint::draw_string(pixelbuf, textpart, textpos, default_text_posn, smalltext, image_width, image_height);
                    textpart[0] = symbol->text[11];
                    textpart[1] = '\0';
                    textpos = 2 * (100 + xoffset);
                    zint::draw_string(pixelbuf, textpart, textpos, default_text_posn, smalltext, image_width, image_height);
                    textdone = 1;
                    switch(strlen(addon)) {
                        case 2:
                            textpos = 2 * (xoffset + 116);
                            zint::draw_string(pixelbuf, addon, textpos, image_height - (addon_text_posn * 2) - 13, smalltext, image_width, image_height);
                            break;
                        case 5:
                            textpos = 2 * (xoffset + 130);
                            zint::draw_string(pixelbuf, addon, textpos, image_height - (addon_text_posn * 2) - 13, smalltext, image_width, image_height);
                            break;
                    }
                    
                }
                
                if (((symbol->symbology == BARCODE_UPCE) && (symbol->rows == 1)) || (symbol->symbology == BARCODE_UPCE_CC)) {
                    /* guard bar extensions and text formatting for UPCE */
                    zint::draw_bar(pixelbuf, (0 + xoffset) * 2, 1 * 2, (4 + (int)yoffset) * 2, 5 * 2, image_width, image_height);
                    zint::draw_bar(pixelbuf, (2 + xoffset) * 2, 1 * 2, (4 + (int)yoffset) * 2, 5 * 2, image_width, image_height);
                    zint::draw_bar(pixelbuf, (46 + xoffset) * 2, 1 * 2, (4 + (int)yoffset) * 2, 5 * 2, image_width, image_height);
                    zint::draw_bar(pixelbuf, (48 + xoffset) * 2, 1 * 2, (4 + (int)yoffset) * 2, 5 * 2, image_width, image_height);
                    zint::draw_bar(pixelbuf, (50 + xoffset) * 2, 1 * 2, (4 + (int)yoffset) * 2, 5 * 2, image_width, image_height);
                    
                    textpart[0] = symbol->text[0];
                    textpart[1] = '\0';
                    textpos = 2 * (-5 + xoffset);
                    zint::draw_string(pixelbuf, textpart, textpos, default_text_posn, smalltext, image_width, image_height);
                    for(i = 0; i < 6; i++) {
                        textpart[i] = symbol->text[i + 1];
                    }
                    textpart[6] = '\0';
                    textpos = 2 * (24 + xoffset);
                    zint::draw_string(pixelbuf, textpart, textpos, default_text_posn, smalltext, image_width, image_height);
                    textpart[0] = symbol->text[7];
                    textpart[1] = '\0';
                    textpos = 2 * (55 + xoffset);
                    zint::draw_string(pixelbuf, textpart, textpos, default_text_posn, smalltext, image_width, image_height);
                    textdone = 1;
                    switch(strlen(addon)) {
                        case 2:
                            textpos = 2 * (xoffset + 70);
                            zint::draw_string(pixelbuf, addon, textpos, image_height - (addon_text_posn * 2) - 13, smalltext, image_width, image_height);
                            break;
                        case 5:
                            textpos = 2 * (xoffset + 84);
                            zint::draw_string(pixelbuf, addon, textpos, image_height - (addon_text_posn * 2) - 13, smalltext, image_width, image_height);
                            break;
                    }
                    
                }
                
                xoffset -= comp_offset;
                
                /* Put boundary bars or box around symbol */
                if(((symbol->output_options & BARCODE_BOX) != 0) || ((symbol->output_options & BARCODE_BIND) != 0)) {
                    /* boundary bars */
                    zint::draw_bar(pixelbuf, 0, (symbol->width + xoffset + xoffset) * 2, textoffset * 2, symbol->border_width * 2, image_width, image_height);
                    zint::draw_bar(pixelbuf, 0, (symbol->width + xoffset + xoffset) * 2, (textoffset + symbol->height + symbol->border_width) * 2, symbol->border_width * 2, image_width, image_height);
                    if((symbol->output_options & BARCODE_BIND) != 0) {
                        if((symbol->rows > 1) && (zint::is_stackable(symbol->symbology) == 1)) {
                            /* row binding */
                            for(r = 1; r < symbol->rows; r++) {
                                zint::draw_bar(pixelbuf, xoffset * 2, symbol->width * 2, ((r * row_height) + textoffset + yoffset - 1) * 2, 2 * 2, image_width, image_height);
                            }
                        }
                    }
                }
                
                if((symbol->output_options & BARCODE_BOX) != 0) {
                    /* side bars */
                    zint::draw_bar(pixelbuf, 0, symbol->border_width * 2, textoffset * 2, (symbol->height + (2 * symbol->border_width)) * 2, image_width, image_height);
                    zint::draw_bar(pixelbuf, (symbol->width + xoffset + xoffset - symbol->border_width) * 2, symbol->border_width * 2, textoffset * 2, (symbol->height + (2 * symbol->border_width)) * 2, image_width, image_height);
                }
                
                /* Put the human readable text at the bottom */
                if((textdone == 0) && (zint::ustrlen(local_text) != 0)) {
                    textpos = (image_width / 2);
                    zint::draw_string(pixelbuf, (char*)local_text, textpos, default_text_posn, smalltext, image_width, image_height);
                }
                
            }
            
        }
    //create png
    if(pixelbuf)
    {
        png_structp  png_ptr;
        png_infop  info_ptr;
        png_colorp palette;
        unsigned int fg_color[4] = {0, 0, 0, 255};
        unsigned int bg_color[4] = {255, 255, 255, 255};
        png_byte alpha_values[2];
        unsigned char *row;
        
        row = (unsigned char *)malloc((image_width + 7) / 8);
        if(row != NULL)
        {
            png_ptr = png_create_write_struct(PNG_LIBPNG_VER_STRING, NULL, NULL, NULL);
            if(png_ptr != NULL)
            {
                info_ptr = png_create_info_struct(png_ptr);
                if(info_ptr == NULL)
                {
                    png_destroy_write_struct(&png_ptr, NULL);
                }else
                {
                    if(setjmp(png_jmpbuf(png_ptr))) {
                        png_destroy_write_struct(&png_ptr, &info_ptr);
                    }else
                    {
                        palette = (png_colorp) malloc(sizeof(png_color) * 2);
                        if(palette != NULL)
                        {
                            palette[0].red   = fg_color[0];
                            palette[0].green = fg_color[1];
                            palette[0].blue  = fg_color[2];
                            palette[1].red   = bg_color[0];
                            palette[1].green = bg_color[1];
                            palette[1].blue  = bg_color[2];
                            alpha_values[0] = fg_color[3];
                            alpha_values[1] = bg_color[3];
                            png_set_PLTE(png_ptr, info_ptr, palette, 2);
                            png_set_tRNS(png_ptr, info_ptr, alpha_values, 2, NULL);
                            
                            C_BLOB png;
                            
                            png_set_write_fn(png_ptr, (png_voidp)&png, write_data_fn, output_flush_fn);
                            
                            png_set_compression_level(png_ptr, Z_BEST_COMPRESSION);
                            
                            switch(rotate_angle)
                            {
                                case 90:
                                case 270:
                                    png_set_IHDR(png_ptr, info_ptr,
                                                             image_height, image_width,
                                                             8,
                                                             PNG_COLOR_TYPE_RGB,
                                                             PNG_INTERLACE_NONE,
                                                             PNG_COMPRESSION_TYPE_DEFAULT,
                                                             PNG_FILTER_TYPE_DEFAULT);
                                    break;
                                default:
                                    png_set_IHDR(png_ptr, info_ptr,
                                                             image_width, image_height,
                                                             8,
                                                             PNG_COLOR_TYPE_RGB,
                                                             PNG_INTERLACE_NONE,
                                                             PNG_COMPRESSION_TYPE_DEFAULT,
                                                             PNG_FILTER_TYPE_DEFAULT);
                                    break;
                            }
                            
                            png_set_pHYs(png_ptr, info_ptr,
                                                     dpi * INCHES_PER_METER,
                                                     dpi * INCHES_PER_METER,
                                                     PNG_RESOLUTION_METER);
                            
                            png_set_packing(png_ptr);
                            
                            png_write_info(png_ptr, info_ptr);
                            
                            #ifndef _MSC_VER
                                unsigned char outdata[image_width * 3];
                            #else
                                unsigned char* outdata = (unsigned char*)_alloca(image_width * 3);
                            #endif
                            int i, _row, _column;
                            int fgred, fggrn, fgblu, bgred, bggrn, bgblu;
                            fgred = 0x01;
                            fggrn = 0x01;
                            fgblu = 0x01;
                            if(no_background)
                            {
                            bgred = 0x00;//alpha
                            bggrn = 0x00;
                            bgblu = 0x00;
                            }else{
                                bgred = 0xFF;
                                bggrn = 0xFF;
                                bgblu = 0xFF;
                            }
                            switch(rotate_angle)
                            {
                                case 0:
                                    for(_row = 0; _row < image_height; _row++) {
                                        for(_column = 0; _column < image_width; _column++) {
                                            i = _column * 3;
                                            switch(*(pixelbuf + (image_width * _row) + _column))
                                            {
                                                case '1':
                                                    outdata[i] = fgred;
                                                    outdata[i + 1] = fggrn;
                                                    outdata[i + 2] = fgblu;
                                                    break;
                                                default:
                                                        outdata[i] = bgred;
                                                        outdata[i + 1] = bggrn;
                                                        outdata[i + 2] = bgblu;
                                                    break;
                                            }
                                        }
                                        /* write row contents to file */
                                        unsigned char *image_data = outdata;
                                        png_write_row(png_ptr, image_data);
                                    }
                                    break;
                                case 90:
                                    for(_row = 0; _row < image_width; _row++) {
                                        for(_column = 0; _column < image_height; _column++) {
                                            i = _column * 3;
                                            switch(*(pixelbuf + (image_width * (image_height - _column - 1)) + _row))
                                            {
                                                case '1':
                                                    outdata[i] = fgred;
                                                    outdata[i + 1] = fggrn;
                                                    outdata[i + 2] = fgblu;
                                                    break;
                                                default:
                                                    outdata[i] = bgred;
                                                    outdata[i + 1] = bggrn;
                                                    outdata[i + 2] = bgblu;
                                                    break;
                                                    
                                            }
                                        }
                                        /* write row contents to file */
                                        unsigned char *image_data = outdata;
                                        png_write_row(png_ptr, image_data);
                                    }
                                    break;
                                case 180:
                                    for(_row = 0; _row < image_height; _row++) {
                                        for(_column = 0; _column < image_width; _column++) {
                                            i = _column * 3;
                                            switch(*(pixelbuf + (image_width * (image_height - _row - 1)) + (image_width - _column - 1)))
                                            {
                                                case '1':
                                                    outdata[i] = fgred;
                                                    outdata[i + 1] = fggrn;
                                                    outdata[i + 2] = fgblu;
                                                    break;
                                                default:
                                                    outdata[i] = bgred;
                                                    outdata[i + 1] = bggrn;
                                                    outdata[i + 2] = bgblu;
                                                    break;
                                                    
                                            }
                                        }
                                        /* write row contents to file */
                                        unsigned char *image_data = outdata;
                                        png_write_row(png_ptr, image_data);
                                    }
                                    break;
                                case 270:
                                    for(_row = 0; _row < image_width; row++) {
                                        for(_column = 0; _column < image_height; _column++) {
                                            i = _column * 3;
                                            switch(*(pixelbuf + (image_width * _column) + (image_width - _row - 1)))
                                            {
                                                case '1':
                                                    outdata[i] = fgred;
                                                    outdata[i + 1] = fggrn;
                                                    outdata[i + 2] = fgblu;
                                                    break;
                                                default:
                                                    outdata[i] = bgred;
                                                    outdata[i + 1] = bggrn;
                                                    outdata[i + 2] = bgblu;
                                                    break;
                                                    
                                            }
                                        }
                                        /* write row contents to file */
                                        unsigned char *image_data = outdata;
                                        png_write_row(png_ptr, image_data);
                                    }
                                    break;
                            }
                            
                            png_write_end(png_ptr, info_ptr);
                              
                            free(palette);
                            
                            if(o) {
                                
                                C_TEXT dump;
                                png.toB64Text(&dump);
                                
                                CUTF16String u;
                                dump.copyUTF16String(&u);
                                ob_set_a(o, L"data", &u);
                                
                                PA_Picture p = PA_CreatePicture((void *)png.getBytesPtr(), png.getBytesLength());
                                PA_Variable v = PA_CreateVariable(eVK_Picture);
                                PA_SetPictureVariable(&v, p);/* we let go, so don't dispose */

                                CUTF16String ukey;
                                json_wconv(L"image", &ukey);
                                PA_Unistring key = PA_CreateUnistring((PA_Unichar *)ukey.c_str());
                                
                                PA_SetObjectProperty(o, &key, v);
                                
                                PA_DisposeUnistring(&key);/* we still own it, so dispose */
                                PA_ClearVariable(&v);
                            }
                            
                        }
                        
                    }
                    png_destroy_write_struct(&png_ptr, &info_ptr);
                }
                
            }
            free(row);
        }
        free(pixelbuf);
    }

}
